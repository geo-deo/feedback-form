// server/app.js
import express from "express";
import cors from "cors";
import prisma from "./db.js"; // PrismaClient
import { v4 as uuidv4 } from "uuid";
import OpenAI from "openai";
import admin from "./firebase.js"; // ğŸ”¹ Firebase SDK

const app = express();
app.use(express.json());
app.use(cors({ origin: "*" }));

// Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ OpenAI
const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// ğŸ”¹ Middleware Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ñ‚Ğ¾ĞºĞµĞ½Ğ° Firebase
async function verifyToken(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    return res.status(401).json({ error: "No token provided" });
  }

  const token = authHeader.split(" ")[1]; // "Bearer <token>"

  try {
    const decoded = await admin.auth().verifyIdToken(token);
    req.user = decoded; // { uid, email, ... }
    next();
  } catch (err) {
    console.error("Token verification error:", err);
    res.status(401).json({ error: "Invalid token" });
  }
}

// Healthcheck
app.get("/api/health", (_req, res) => res.json({ ok: true }));

// ===== AI Chat Endpoint =====
app.post("/api/ai-chat", async (req, res) => {
  const { message } = req.body;
  if (!message) return res.status(400).json({ error: "No message provided" });

  try {
    const completion = await client.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content:
            "Ğ¢Ñ‹ â€” Ğ´Ñ€ÑƒĞ¶ĞµĞ»ÑĞ±Ğ½Ñ‹Ğ¹ Ğ°ÑÑĞ¸ÑÑ‚ĞµĞ½Ñ‚. Ğ’Ğ¡Ğ•Ğ“Ğ”Ğ Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°Ğ¹ Ğ½Ğ° Ñ‚Ğ¾Ğ¼ Ğ¶Ğµ ÑĞ·Ñ‹ĞºĞµ, Ğ½Ğ° ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ¼ Ğ±Ñ‹Ğ» Ğ·Ğ°Ğ´Ğ°Ğ½ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¼.",
        },
        { role: "user", content: message },
      ],
    });

    res.json({ reply: completion.choices[0].message.content });
  } catch (err) {
    console.error("AI error:", err);
    res.status(500).json({ error: "AI request failed" });
  }
});

// ===== Feedback Endpoints =====

// POST /api/feedback â€” ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ
app.post("/api/feedback", async (req, res) => {
  try {
    const { name, email, message } = req.body || {};
    if (!name || !email || !message) {
      return res
        .status(400)
        .json({ ok: false, error: "Missing required fields" });
    }

    const feedback = await prisma.feedback.create({
      data: {
        id: uuidv4(),
        name,
        email,
        message,
        ip: req.ip,
        userAgent: req.get("User-Agent"),
      },
    });

    res.json({ ok: true, feedback });
  } catch (error) {
    console.error("DB error:", error);
    res.status(500).json({ ok: false, error: "DB error" });
  }
});

// GET /api/feedback â€” ÑĞ¿Ğ¸ÑĞ¾Ğº Ñ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸ĞµĞ¹ + Ğ¿Ğ°Ğ³Ğ¸Ğ½Ğ°Ñ†Ğ¸ĞµĞ¹
app.get("/api/feedback", async (req, res) => {
  try {
    const { page = 1, limit = 10, search = "", dateFrom, dateTo } = req.query;
    const skip = (page - 1) * limit;

    const where = {};
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { email: { contains: search, mode: "insensitive" } },
        { message: { contains: search, mode: "insensitive" } },
      ];
    }
    if (dateFrom || dateTo) {
      where.createdAt = {};
      if (dateFrom) where.createdAt.gte = new Date(dateFrom);
      if (dateTo) where.createdAt.lte = new Date(dateTo);
    }

    const [items, total] = await Promise.all([
      prisma.feedback.findMany({
        where,
        orderBy: { createdAt: "desc" },
        skip: Number(skip),
        take: Number(limit),
      }),
      prisma.feedback.count({ where }),
    ]);

    const totalPages = Math.ceil(total / limit);

    res.json({
      ok: true,
      items,
      total,
      totalPages,
      page: Number(page),
    });
  } catch (error) {
    console.error("DB error:", error);
    res.status(500).json({ ok: false, error: "DB error" });
  }
});

// PATCH /api/feedback/:id â€” Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ
app.patch("/api/feedback/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { name, email, message } = req.body || {};

    const feedback = await prisma.feedback.update({
      where: { id },
      data: { name, email, message },
    });

    res.json({ ok: true, feedback });
  } catch (error) {
    if (error.code === "P2025") {
      return res.status(404).json({ ok: false, error: "Not found" });
    }
    console.error("DB error:", error);
    res.status(500).json({ ok: false, error: "DB error" });
  }
});

// DELETE /api/feedback/:id â€” ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ
app.delete("/api/feedback/:id", async (req, res) => {
  try {
    const { id } = req.params;
    await prisma.feedback.delete({ where: { id } });
    res.json({ ok: true, id });
  } catch (error) {
    if (error.code === "P2025") {
      return res.status(404).json({ ok: false, error: "Not found" });
    }
    console.error("DB error:", error);
    res.status(500).json({ ok: false, error: "DB error" });
  }
});

// ğŸ”¹ Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ·Ğ°Ñ‰Ğ¸Ñ‰Ñ‘Ğ½Ğ½Ñ‹Ğ¹ Ñ€Ğ¾ÑƒÑ‚
app.get("/api/secure", verifyToken, (req, res) => {
  res.json({
    ok: true,
    uid: req.user.uid,
    email: req.user.email,
  });
});

// POST /api/login â€” Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
app.post("/api/login", (req, res) => {
  const { email, password } = req.body || {};

  // Ğ¿Ğ¾ĞºĞ° Ñ‡Ñ‚Ğ¾ Ğ·Ğ°Ñ…Ğ°Ñ€Ğ´ĞºĞ¾Ğ´Ğ¸Ğ¼ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
  if (email === "admin@test.com" && password === "123456") {
    return res.json({ ok: true, token: "fake-jwt-token" });
  }

  res.status(401).json({ ok: false, error: "Invalid credentials" });
});


// Root
app.get("/", (_req, res) => {
  res.send("âœ… Feedback API with PostgreSQL + Prisma + OpenAI is running ğŸš€");
});

export default app;